#I "src/OBO.NET/bin/Debug/netstandard2.0"
#I "src/OBO.NET/bin/Release/netstandard2.0"
#I "src/OBO.NET.CodeGeneration/bin/Debug/netstandard2.0"
#I "src/OBO.NET.CodeGeneration/bin/Release/netstandard2.0"

#r "OBO.NET.dll"
#r "OBO.NET.CodeGeneration.dll"

open OBO.NET
open OBO.NET.DBXref
open OBO.NET.CodeGeneration

#r "nuget: FSharpAux"
#r "nuget: ARCTokenization"

open FSharpAux
open FSharpAux.Regex
open ARCTokenization.Terms

open System

open type System.Environment




type OboOntology =

    {
        Terms                                           : OboTerm list
        TypeDefs                                        : OboTypeDef list
        FormatVersion                                   : string
        DataVersion                                     : string option
        Ontology                                        : string option
        Date                                            : DateTime option
        SavedBy                                         : string option
        AutoGeneratedBy                                 : string option
        Subsetdefs                                      : string list
        Imports                                         : string list               // needs its own type (Record?)
        Synonymtypedefs                                 : string list               // rethink type, maybe create a mother type (Union? Maybe Record'd be better)
        Idspaces                                        : string list               // rethink as own Record type
        DefaultRelationshipIdPrefix                     : string option
        IdMappings                                      : string list               // rethink: maybe a new record? or TermRelation<string>?
        Remarks                                         : string list
        TreatXrefsAsEquivalents                         : string list
        TreatXrefsAsGenusDifferentias                   : string list               // rethink: maybe a new record? or plain string option?
        TreatXrefsAsRelationships                       : string list               // maybe better as its own (Record/Union?) type
        TreatXrefsAsIsAs                                : string list
        RelaxUniqueIdentifierAssumptionForNamespaces    : string list
        RelaxUniqueLabelAssumptionForNamespaces         : string list
    }

    /// Creates an OboOntology based on the given parameters.
    static member create terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idspaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces =
        {
            Terms                                           = terms
            TypeDefs                                        = typedefs
            FormatVersion                                   = formatVersion
            DataVersion                                     = dataVersion
            Ontology                                        = ontology
            Date                                            = date
            SavedBy                                         = savedBy
            AutoGeneratedBy                                 = autoGeneratedBy
            Subsetdefs                                      = subsetdefs
            Imports                                         = imports
            Synonymtypedefs                                 = synonymtypedefs
            Idspaces                                        = idspaces
            DefaultRelationshipIdPrefix                     = defaultRelationshipIdPrefix
            IdMappings                                      = idMappings
            Remarks                                         = remarks
            TreatXrefsAsEquivalents                         = treatXrefsAsEquivalents
            TreatXrefsAsGenusDifferentias                   = treatXrefsAsGenusDifferentias
            TreatXrefsAsRelationships                       = treatXrefsAsRelationships
            TreatXrefsAsIsAs                                = treatXrefsAsIsAs
            RelaxUniqueIdentifierAssumptionForNamespaces    = relaxUniqueIdentifierAssumptionForNamespaces
            RelaxUniqueLabelAssumptionForNamespaces         = relaxUniqueLabelAssumptionForNamespaces
        }

    /// Creates an OboOntology based on the given arguments.
    static member Create(terms, typedefs, formatVersion, ?DataVersion, ?Ontology, ?Date, ?SavedBy, ?AutoGeneratedBy, ?Subsetdefs, ?Imports, ?Synonymtypedefs, ?Idspaces, ?DefaultRelationshipIdPrefix, ?IdMappings, ?Remarks, ?TreatXrefsAsEquivalents, ?TreatXrefsAsGenusDifferentias, ?TreatXrefsAsRelationships, ?TreatXrefsAsIsAs, ?RelaxUniqueIdentifierAssumptionForNamespaces, ?RelaxUniqueLabelAssumptionForNamespaces) = {
        Terms                                           = terms
        TypeDefs                                        = typedefs
        FormatVersion                                   = formatVersion
        DataVersion                                     = DataVersion
        Ontology                                        = Ontology
        Date                                            = Date
        SavedBy                                         = SavedBy
        AutoGeneratedBy                                 = AutoGeneratedBy
        Subsetdefs                                      = defaultArg Subsetdefs []
        Imports                                         = defaultArg Imports []
        Synonymtypedefs                                 = defaultArg Synonymtypedefs []
        Idspaces                                        = defaultArg Idspaces []
        DefaultRelationshipIdPrefix                     = DefaultRelationshipIdPrefix
        IdMappings                                      = defaultArg IdMappings []
        Remarks                                         = defaultArg Remarks []
        TreatXrefsAsEquivalents                         = defaultArg TreatXrefsAsEquivalents []
        TreatXrefsAsGenusDifferentias                   = defaultArg TreatXrefsAsGenusDifferentias []
        TreatXrefsAsRelationships                       = defaultArg TreatXrefsAsRelationships []
        TreatXrefsAsIsAs                                = defaultArg TreatXrefsAsIsAs []
        RelaxUniqueIdentifierAssumptionForNamespaces    = defaultArg RelaxUniqueIdentifierAssumptionForNamespaces []
        RelaxUniqueLabelAssumptionForNamespaces         = defaultArg RelaxUniqueLabelAssumptionForNamespaces []
    }

//let res = (createRegex RegexOptions.None """format-version\s:\s*(?<formatVersion>.+)""").Match "format-version : 17.5.1"
//let res = (createRegex RegexOptions.None """format-version\s:\s*(?<formatVersion>.+)""").Match "format-verson: 17.5.1"
//res.Groups["formatVersion"].Value
//DateTime.ParseExact("31:12:2000 23:59", "dd:MM:yyyy HH:mm", Globalization.CultureInfo.InvariantCulture)

    /// Reads an OBO Ontology containing document header tags, and term and type def stanzas from lines.
    static member fromLines verbose (input : seq<string>) =

        let rxFormatVersion                                 = createRegex RegexOptions.None @"format-version\s*:\s*(?<formatVersion>.+)"
        let rxDataVersion                                   = createRegex RegexOptions.None @"(?:data-version|version)\s*:\s*(?<dataVersion>.+)"
        let rxOntology                                      = createRegex RegexOptions.None @"ontology\s*:\s*(?<ontology>.+)"
        let rxDate                                          = createRegex RegexOptions.None @"date\s*:\s*(?<date>\d{2}:\d{2}:\d{4} \d{2}:\d{2})"
        let rxSavedBy                                       = createRegex RegexOptions.None @"saved-by\s*:\s*(?<savedBy>.+)"
        let rxAutoGeneratedBy                               = createRegex RegexOptions.None @"auto-generated-by\s*:\s*(?<autoGeneratedBy>.+)"
        let rxSubsetdef                                     = createRegex RegexOptions.None @"subsetdef\s*:\s*(?<subsetdef>.+)"
        let rxImport                                        = createRegex RegexOptions.None @"import\s*:\s*(?<import>.+)"
        let rxSynonymtypedef                                = createRegex RegexOptions.None @"synonymtypedef\s*:\s*(?<synonymtypedef>.+)"
        let rxIdspace                                       = createRegex RegexOptions.None @"idspace\s*:\s*(?<idspace>.+)"
        let rxDefaultRelationshipIdPrefix                   = createRegex RegexOptions.None @"default-relationship-id-prefix\s*:\s*(?<defaultRelationshipIdPrefix>.+)"
        let rxIdMapping                                     = createRegex RegexOptions.None @"id-mapping\s*:\s*(?<idMapping>.+)"
        let rxRemark                                        = createRegex RegexOptions.None @"remark\s*:\s*(?<remark>.+)"
        let rxTreatXrefsAsEquivalent                        = createRegex RegexOptions.None @"treat-xrefs-as-equivalent\s*:\s*(?<treatXrefsAsEquivalent>.+)"
        let rxTreatXrefsAsGenusDifferentia                  = createRegex RegexOptions.None @"treat-xrefs-as-genus-differentia\s*:\s*(?<treatXrefsAsGenusDifferentia>.+)"
        let rxTreatXrefsAsRelationship                      = createRegex RegexOptions.None @"treat-xrefs-as-relationship\s*:\s*(?<treatXrefsAsRelationship>.+)"
        let rxTreatXrefsAsIsA                               = createRegex RegexOptions.None @"treat-xrefs-as-is_a\s*:\s*(?<treatXrefsAsIsA>.+)"
        let rxRelaxUniqueIdentifierAssumptionForNamespace   = createRegex RegexOptions.None @"relax-unique-identifier-assumption-for-namespace\s*:\s*(?<relaxUniqueIdentifierAssumptionForNamespace>.+)"
        let rxRelaxUniqueLabelAssumptionForNamespace        = createRegex RegexOptions.None @"relax-unique-label-assumption-for-namespace\s*:\s*(?<relaxUniqueLabelAssumptionForNamespace>.+)"

        let en = input.GetEnumerator()

        let rec loop (en : System.Collections.Generic.IEnumerator<string>) terms typedefs formatVersion (dataVersion : string option) ontology (date : DateTime option) (savedBy : string option) (autoGeneratedBy : string option) subsetdefs imports synonymtypedefs idSpaces (defaultRelationshipIdPrefix : string option) idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces lineNumber =

            match en.MoveNext() with
            | true ->             
                match trimComment en.Current with
                | "[Term]"    -> 
                    let lineNumber,parsedTerm = OboTerm.fromLines verbose en lineNumber "" "" false [] "" "" [] [] [] [] [] [] [] [] false [] [] [] false "" ""
                    loop en (parsedTerm :: terms) typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsIsAs treatXrefsAsRelationships treatXrefsAsGenusDifferentias relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces lineNumber
                | "[Typedef]" -> 
                    let lineNumber,parsedTypeDef = OboTypeDef.fromLines verbose en lineNumber "" "" "" "" [] [] false false false false false false false
                    loop en terms (parsedTypeDef :: typedefs) formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces lineNumber
                | x when (rxFormatVersion.Match x).Success -> 
                    if formatVersion <> "" then printfn "WARNING: Duplicate format-version in document header tags!"
                    loop en terms typedefs (rxFormatVersion.Match x).Groups["formatVersion"].Value dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxDataVersion.Match x).Success ->
                    if dataVersion.IsSome then printfn "WARNING: Duplicate data-version in document header tags!"
                    loop en terms typedefs formatVersion (Some (rxDataVersion.Match x).Groups["dataVersion"].Value) ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxOntology.Match x).Success ->
                    loop en terms typedefs formatVersion dataVersion ((rxOntology.Match x).Groups["ontology"].Value |> Some) date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxDate.Match x).Success -> 
                    if date.IsSome then printfn "WARNING: Duplicate date in document header tags!"
                    let parsedDate = 
                        try DateTime.ParseExact((rxDate.Match x).Groups["date"].Value, "dd:MM:yyyy HH:mm", Globalization.CultureInfo.InvariantCulture) |> Some with
                            _ -> 
                                printfn "ERROR: Inproper date given!"
                                None
                    loop en terms typedefs formatVersion dataVersion ontology parsedDate savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxSavedBy.Match x).Success -> 
                    if savedBy.IsSome then printfn "WARNING: Duplicate saved-by in document header tags!"
                    loop en terms typedefs formatVersion dataVersion ontology date ((rxSavedBy.Match x).Groups["savedBy"].Value |> Some) autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxAutoGeneratedBy.Match x).Success -> 
                    if autoGeneratedBy.IsSome then printfn "WARNING: Duplicate auto-generated-by in document header tags!"
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy ((rxAutoGeneratedBy.Match x).Groups["autoGeneratedBy"].Value |> Some) subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxSubsetdef.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy ((rxSubsetdef.Match x).Groups["subsetdef"].Value :: subsetdefs) imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxImport.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs ((rxImport.Match x).Groups["import"].Value :: imports) synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxSynonymtypedef.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports ((rxSynonymtypedef.Match x).Groups["synonymtypedef"].Value :: synonymtypedefs) idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxIdspace.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs ((rxIdspace.Match x).Groups["idspace"].Value :: idSpaces) defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxDefaultRelationshipIdPrefix.Match x).Success -> 
                    if defaultRelationshipIdPrefix.IsSome then printfn "WARNING: Duplicate default-relationship-id-prefix in document header tags!"
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces ((rxDefaultRelationshipIdPrefix.Match x).Groups["defaultRelationshipIdPrefix"].Value |> Some) idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxIdMapping.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix ((rxIdMapping.Match x).Groups["idMapping"].Value :: idMappings) remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxRemark.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings ((rxRemark.Match x).Groups["remark"].Value :: remarks) treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxTreatXrefsAsEquivalent.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks ((rxTreatXrefsAsEquivalent.Match x).Groups["treatXrefsAsEquivalent"].Value :: treatXrefsAsEquivalents) treatXrefsAsIsAs treatXrefsAsRelationships treatXrefsAsGenusDifferentias relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxTreatXrefsAsGenusDifferentia.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents ((rxTreatXrefsAsGenusDifferentia.Match x).Groups["treatXrefsAsGenusDifferentia"].Value :: treatXrefsAsGenusDifferentias) treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxTreatXrefsAsRelationship.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias ((rxTreatXrefsAsRelationship.Match x).Groups["treatXrefsAsRelationship"].Value :: treatXrefsAsRelationships) treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxTreatXrefsAsIsA.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships ((rxTreatXrefsAsIsA.Match x).Groups["treatXrefsAsIsA"].Value :: treatXrefsAsIsAs) relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxRelaxUniqueIdentifierAssumptionForNamespace.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs ((rxRelaxUniqueIdentifierAssumptionForNamespace.Match x).Groups["relaxUniqueIdentifierAssumptionForNamespace"].Value :: relaxUniqueIdentifierAssumptionForNamespaces) relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxRelaxUniqueLabelAssumptionForNamespace.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces ((rxRelaxUniqueLabelAssumptionForNamespace.Match x).Groups["relaxUniqueLabelAssumptionForNamespace"].Value :: relaxUniqueLabelAssumptionForNamespaces) (lineNumber + 1)
                | _ -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
            | false -> 
                OboOntology.create (List.rev terms) (List.rev typedefs) formatVersion dataVersion ontology date savedBy autoGeneratedBy (List.rev subsetdefs) (List.rev imports) (List.rev synonymtypedefs) (List.rev idSpaces) defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsIsAs treatXrefsAsRelationships treatXrefsAsGenusDifferentias relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces

        loop en [] [] String.Empty None None None None None [] [] [] [] None [] [] [] [] [] [] [] [] 0  // was 1 before

let fl1 = OboOntology.fromLines false (IO.File.ReadAllLines(IO.Path.Combine(__SOURCE_DIRECTORY__, "tests", "OBO.NET.Tests", "References", "HeaderTags_correct.obo")))
let fl2 = OboOntology.fromLines false (IO.File.ReadAllLines(IO.Path.Combine(__SOURCE_DIRECTORY__, "tests", "OBO.NET.Tests", "References", "HeaderTags_incorrect.obo")))
let fl3 = OboOntology.fromLines false (IO.File.ReadAllLines(IO.Path.Combine(__SOURCE_DIRECTORY__, "tests", "OBO.NET.Tests", "References", "HeaderTags_duplicates.obo")))

open ARCTokenization.Terms

open type System.Environment

let expected = 
    $"namespace ARCTokenization.StructuralOntology{NewLine}{NewLine}    open ControlledVocabulary{NewLine}{NewLine}    module Investigation ={NewLine}{NewLine}        let Investigation_Metadata = CvTerm.create(\"INVMSO:00000001\", \"Investigation Metadata\", \"INVMSO\"){NewLine}{NewLine}        let ONTOLOGY_SOURCE_REFERENCE = CvTerm.create(\"INVMSO:00000002\", \"ONTOLOGY SOURCE REFERENCE\", \"INVMSO\"){NewLine}{NewLine}        let Term_Source_Name = CvTerm.create(\"INVMSO:00000003\", \"Term Source Name\", \"INVMSO\")"
    |> String.replace "\r" ""
let actual = 
    CodeGeneration.toSourceCode "Investigation" InvestigationMetadata.ontology 
    |> String.splitS NewLine 
    |> Array.take 11 
    |> String.concat "\n"
    |> String.replace "\r" ""

OBO.NET.OboOntology.toFile @"C:\Repos\CSBiology\OBO.NET\tests\OBO.NET.CodeGeneration.Tests\References\ReferenceOboFile.obo" InvestigationMetadata.ontology
// OBO.NET.OboOntology.toFile @"C:\Repos\CSBiology\OBO.NET\tests\OBO.NET.CodeGeneration.Tests\References\ReferenceOboFile.obo" InvestigationMetadata.ontology

CodeGeneration.toFile "InvestigationMetadata" InvestigationMetadata.ontology @"C:\Repos\CSBiology\OBO.NET\tests\OBO.NET.CodeGeneration.Tests\References\ReferenceSourceFile2.fs"


// DEPRECATED


#I "src/FsOboParser/bin/Debug/netstandard2.0"
#I "src/FsOboParser/bin/Release/netstandard2.0"
#r "FsOboParser.dll"

#r "nuget: IsaDotNet"
//#r "nuget: FsOboParser"
#r "nuget: FSharpAux"


open FsOboParser

open FSharpAux

open System.IO


//let testPath = Path.Combine(__SOURCE_DIRECTORY__,  "./../../nfdi4plants/arc-validate/ErrorClassOntology.obo")

//OboEntries.fromFile true testPath
//let testOntology = OboOntology.fromFile true testPath

let testTerms = [
    OboTerm.Create("test:000", Name = "test0")
    OboTerm.Create("test:001", Name = "test1a", IsA = ["test:000"])
    OboTerm.Create("test:002", Name = "test2", IsA = ["test:001"; "test:000"])
    OboTerm.Create("test:003", Name = "test1b", IsA = ["test:000"])
    OboTerm.Create("test:004", Name = "test1aSyn", Synonyms = [TermSynonym.parseSynonym None 1 "\"test1a\" EXACT []"])
    //OboTerm.Create("test:004", Name = "test1aSyn", Synonyms = [TermSynonym.parseSynonym None 1 "test1a EXACT []"])
]

let testOntology = OboOntology.create testTerms []



//let termOfInterest = testOntology.Terms[5]
//let targetOfInterest = testOntology.Terms[7]

//let emptyTermRelation = Empty termOfInterest
//let targetMissingTermRelation = TargetMissing ("unconnected_to", termOfInterest)
//let targetTermRelation = Target ("connected_to", termOfInterest, targetOfInterest)

//// exemplary
//type MyRelation =
//    | IsA
//    | HasA
//    | PartOf
//    | ConnectedTo
//    | Unknown of string

//let targetTermRelation' = Target (ConnectedTo, termOfInterest, targetOfInterest)



///// Takes a given OboTerm and returns a sequence of scope * OboTerm if the synonym exists in the given OboOntology or scope * None if it does not.
//let tryGetSynonymTerms (term : OboTerm) (onto : OboOntology) =
//    term.Synonyms
//    |> Seq.map (
//        fun s -> 
//            s.Scope,
//            onto.Terms 
//            |> Seq.tryFind (
//                fun t -> 
//                    t.Name = String.replace "\"" "" s.Text
//            )
//    )

///// Takes a given OboTerm and returns a sequence of scope * OboTerm if the synonym exists in the given OboOntology.
//let getSynonymTerms (term : OboTerm) (onto : OboOntology) =
//    term.Synonyms
//    |> Seq.choose (
//        fun s -> 
//            let sto =
//                onto.Terms 
//                |> Seq.tryFind (
//                    fun t -> 
//                        t.Name = String.replace "\"" "" s.Text
//                )
//            match sto with
//            | Some st -> Some (s.Scope, st)
//            | None -> None
//    )

//String.replace "\"" "" (TermSynonym.parseSynonym None 1 "test1a EXACT []").Text

//tryGetSynonymTerms testTerms[4] testOntology
//getSynonymTerms testTerms[4] testOntology


//OboOntology.getRelations testOntology


//testOntology.GetChildOntologyAnnotations(testTerms.Head.Id)
//testOntology.GetChildOntologyAnnotations(testTerms.Head.Id, Depth = 1)
//testOntology.GetChildOntologyAnnotations(testTerms.Head.Id, Depth = 2)



//let performanceTerms = List.init 7000000 (fun i -> OboTerm.Create($"lol:{i}"))
//let performanceOboOntology = OboOntology.create performanceTerms []
//OboOntology.toFile @"C:\Repos\CSBiology\FsOboParser\performanceOntology.obo" performanceOboOntology

//let x = OboOntology.fromFile false @"C:\Repos\CSBiology\FsOboParser\performanceOntology.obo"


//let fileLines = File.ReadAllLines testPath

//OboTerm.fromLines true ((fileLines |> Seq.ofArray).GetEnumerator()) 0

//OboOntology.toFile "myOboOntology.obo" testOboOntology

//Path.Combine("myOboOntology.obo") |> FileInfo

//let myOboTerm = OboTerm.Create("TO:00000000", Name = "testTerm", CreatedBy = "myself")

//let myOboTerm = 
//    OboTerm.create 
//        "TO:00000000" 
//        (Some "testTerm") 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        (Some "myself") 
//        None

//OboTypeDef.Create

//let myOntology = OboOntology.create [myOboTerm] []

//OboOntology.toFile "myOboOntology.obo" myOntology

//let termOfInterest = testOntology.Terms[5]

//let isAs = testOntology.GetParentOntologyAnnotations(termOfInterest.Id)
// output is an ISADotNet.OntologyAnnotation list

//let isAsTerms = isAs |> List.map (fun oa -> testOntology.GetTerm(oa.TermAccessionString.ToString()))
// output is an OboTerm list