#I "src/OBO.NET/bin/Debug/netstandard2.0"
#I "src/OBO.NET/bin/Release/netstandard2.0"
#I "src/OBO.NET.CodeGeneration/bin/Debug/netstandard2.0"
#I "src/OBO.NET.CodeGeneration/bin/Release/netstandard2.0"

#r "OBO.NET.dll"
#r "OBO.NET.CodeGeneration.dll"

open OBO.NET
open OBO.NET.DBXref
open OBO.NET.CodeGeneration

#r "nuget: FSharpAux"
#r "nuget: ARCTokenization"

open FSharpAux
open ARCTokenization.Terms

open type System.Environment




type OboOntology =

    {
        Terms                                           : OboTerm list
        TypeDefs                                        : OboTypeDef list
        FormatVersion                                   : string
        DataVersion                                     : string option
        Ontology                                        : string option
        Date                                            : System.DateTime option
        SavedBy                                         : string option
        AutoGeneratedBy                                 : string option
        Subsetdefs                                      : string list option
        Imports                                         : string list option
        Synonymtypedefs                                 : TermSynonym list option           // rethink type, maybe create a mother type (Union?)
        IdSpaces                                        : string list option                // rethink as own Record type
        DefaultRelationshipIdPrefix                     : string option
        IdMappings                                      : TermRelation<string> list option  // rethink: maybe a new record? or plain string option?
        Remarks                                         : string list option
        TreatXrefsAsEquivalents                         : string list option
        TreatXrefsAsGenusDifferentias                   : TermRelation<string> list option  // rethink: maybe a new record? or plain string option?
        TreatXrefsAsRelationships                       : string list option                // maybe better as its own (record/union?) type
        TreatXrefsAsIsAs                                : string list option
        RelaxUniqueIdentifierAssumptionForNamespaces    : string list option
        RelaxUniqueLabelAssumptionForNamespaces         : string list option
    }

    static member create terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces =
        {
            Terms                                           = terms
            TypeDefs                                        = typedefs
            FormatVersion                                   = formatVersion
            DataVersion                                     = dataVersion
            Ontology                                        = ontology
            Date                                            = date
            SavedBy                                         = savedBy
            AutoGeneratedBy                                 = autoGeneratedBy
            Subsetdefs                                      = subsetdefs
            Imports                                         = imports
            Synonymtypedefs                                 = synonymtypedefs
            IdSpaces                                        = idSpaces
            DefaultRelationshipIdPrefix                     = defaultRelationshipIdPrefix
            IdMappings                                      = idMappings
            Remarks                                         = remarks
            TreatXrefsAsEquivalents                         = treatXrefsAsEquivalents
            TreatXrefsAsGenusDifferentias                   = treatXrefsAsGenusDifferentias
            TreatXrefsAsRelationships                       = treatXrefsAsRelationships
            TreatXrefsAsIsAs                                = treatXrefsAsIsAs
            RelaxUniqueIdentifierAssumptionForNamespaces    = relaxUniqueIdentifierAssumptionForNamespaces
            RelaxUniqueLabelAssumptionForNamespaces         = relaxUniqueLabelAssumptionForNamespaces
        }

    static member Create(terms, typedefs, formatVersion, ?DataVersion, ?Ontology, ?Date, ?SavedBy, ?AutoGeneratedBy, ?Subsetdefs, ?Imports, ?Synonymtypedefs, ?IdSpaces, ?DefaultRelationshipIdPrefix, ?IdMappings, ?Remarks, ?TreatXrefsAsEquivalents, ?TreatXrefsAsGenusDifferentias, ?TreatXrefsAsRelationships, ?TreatXrefsAsIsAs, ?RelaxUniqueIdentifierAssumptionForNamespaces, ?RelaxUniqueLabelAssumptionForNamespaces) = {
        Terms                                           = terms
        TypeDefs                                        = typedefs
        FormatVersion                                   = formatVersion
        DataVersion                                     = DataVersion
        Ontology                                        = Ontology
        Date                                            = Date
        SavedBy                                         = SavedBy
        AutoGeneratedBy                                 = AutoGeneratedBy
        Subsetdefs                                      = Subsetdefs
        Imports                                         = Imports
        Synonymtypedefs                                 = Synonymtypedefs
        IdSpaces                                        = IdSpaces
        DefaultRelationshipIdPrefix                     = DefaultRelationshipIdPrefix
        IdMappings                                      = IdMappings
        Remarks                                         = Remarks
        TreatXrefsAsEquivalents                         = TreatXrefsAsEquivalents
        TreatXrefsAsGenusDifferentias                   = TreatXrefsAsGenusDifferentias
        TreatXrefsAsRelationships                       = TreatXrefsAsRelationships
        TreatXrefsAsIsAs                                = TreatXrefsAsIsAs
        RelaxUniqueIdentifierAssumptionForNamespaces    = RelaxUniqueIdentifierAssumptionForNamespaces
        RelaxUniqueLabelAssumptionForNamespaces         = RelaxUniqueLabelAssumptionForNamespaces
    }

    /// Reads an OBO Ontology containing term and type def stanzas from lines.
    static member fromLines verbose (input : seq<string>) =

        let skipColonSpace s = String.skipWhile ((<>) ':') s |> String.skipWhile ((=) ' ')

        let en = input.GetEnumerator()
        let rec loop (en : System.Collections.Generic.IEnumerator<string>) terms typedefs formatVersion dataVersion lineNumber =

            match en.MoveNext() with
            | true ->             
                let enTrimmed = trimComment en.Current
                match enTrimmed with
                | "[Term]"    -> 
                    let lineNumber,parsedTerm = OboTerm.fromLines verbose en lineNumber "" "" false [] "" "" [] [] [] [] [] [] [] [] false [] [] [] false "" ""
                    loop en (parsedTerm :: terms) typedefs formatVersion dataVersion lineNumber
                | "[Typedef]" -> 
                    let lineNumber,parsedTypeDef = OboTypeDef.fromLines verbose en lineNumber "" "" "" "" [] [] false false false false false false false
                    loop en terms (parsedTypeDef :: typedefs) formatVersion dataVersion lineNumber
                | "format-version" -> loop en terms typedefs (skipColonSpace enTrimmed) dataVersion (lineNumber + 1)
                | "data-version"
                | "version" -> loop en terms typedefs formatVersion (skipColonSpace enTrimmed |> Some) (lineNumber + 1)
                | _ -> loop en terms typedefs formatVersion dataVersion (lineNumber + 1)
            | false -> OboOntology.create (List.rev terms) (List.rev typedefs) formatVersion dataVersion

        loop en [] [] "" None 1




let expected = 
    $"namespace ARCTokenization.StructuralOntology{NewLine}{NewLine}    open ControlledVocabulary{NewLine}{NewLine}    module Investigation ={NewLine}{NewLine}        let Investigation_Metadata = CvTerm.create(\"INVMSO:00000001\", \"Investigation Metadata\", \"INVMSO\"){NewLine}{NewLine}        let ONTOLOGY_SOURCE_REFERENCE = CvTerm.create(\"INVMSO:00000002\", \"ONTOLOGY SOURCE REFERENCE\", \"INVMSO\"){NewLine}{NewLine}        let Term_Source_Name = CvTerm.create(\"INVMSO:00000003\", \"Term Source Name\", \"INVMSO\")"
    |> String.replace "\r" ""
let actual = 
    CodeGeneration.toSourceCode "Investigation" InvestigationMetadata.ontology 
    |> String.splitS NewLine 
    |> Array.take 11 
    |> String.concat "\n"
    |> String.replace "\r" ""

OBO.NET.OboOntology.toFile @"C:\Repos\CSBiology\OBO.NET\tests\OBO.NET.CodeGeneration.Tests\References\ReferenceOboFile.obo" InvestigationMetadata.ontology


// DEPRECATED


#I "src/FsOboParser/bin/Debug/netstandard2.0"
#I "src/FsOboParser/bin/Release/netstandard2.0"
#r "FsOboParser.dll"

#r "nuget: IsaDotNet"
//#r "nuget: FsOboParser"
#r "nuget: FSharpAux"


open FsOboParser

open FSharpAux

open System.IO


//let testPath = Path.Combine(__SOURCE_DIRECTORY__,  "./../../nfdi4plants/arc-validate/ErrorClassOntology.obo")

//OboEntries.fromFile true testPath
//let testOntology = OboOntology.fromFile true testPath

let testTerms = [
    OboTerm.Create("test:000", Name = "test0")
    OboTerm.Create("test:001", Name = "test1a", IsA = ["test:000"])
    OboTerm.Create("test:002", Name = "test2", IsA = ["test:001"; "test:000"])
    OboTerm.Create("test:003", Name = "test1b", IsA = ["test:000"])
    OboTerm.Create("test:004", Name = "test1aSyn", Synonyms = [TermSynonym.parseSynonym None 1 "\"test1a\" EXACT []"])
    //OboTerm.Create("test:004", Name = "test1aSyn", Synonyms = [TermSynonym.parseSynonym None 1 "test1a EXACT []"])
]

let testOntology = OboOntology.create testTerms []



//let termOfInterest = testOntology.Terms[5]
//let targetOfInterest = testOntology.Terms[7]

//let emptyTermRelation = Empty termOfInterest
//let targetMissingTermRelation = TargetMissing ("unconnected_to", termOfInterest)
//let targetTermRelation = Target ("connected_to", termOfInterest, targetOfInterest)

//// exemplary
//type MyRelation =
//    | IsA
//    | HasA
//    | PartOf
//    | ConnectedTo
//    | Unknown of string

//let targetTermRelation' = Target (ConnectedTo, termOfInterest, targetOfInterest)



///// Takes a given OboTerm and returns a sequence of scope * OboTerm if the synonym exists in the given OboOntology or scope * None if it does not.
//let tryGetSynonymTerms (term : OboTerm) (onto : OboOntology) =
//    term.Synonyms
//    |> Seq.map (
//        fun s -> 
//            s.Scope,
//            onto.Terms 
//            |> Seq.tryFind (
//                fun t -> 
//                    t.Name = String.replace "\"" "" s.Text
//            )
//    )

///// Takes a given OboTerm and returns a sequence of scope * OboTerm if the synonym exists in the given OboOntology.
//let getSynonymTerms (term : OboTerm) (onto : OboOntology) =
//    term.Synonyms
//    |> Seq.choose (
//        fun s -> 
//            let sto =
//                onto.Terms 
//                |> Seq.tryFind (
//                    fun t -> 
//                        t.Name = String.replace "\"" "" s.Text
//                )
//            match sto with
//            | Some st -> Some (s.Scope, st)
//            | None -> None
//    )

//String.replace "\"" "" (TermSynonym.parseSynonym None 1 "test1a EXACT []").Text

//tryGetSynonymTerms testTerms[4] testOntology
//getSynonymTerms testTerms[4] testOntology


//OboOntology.getRelations testOntology


//testOntology.GetChildOntologyAnnotations(testTerms.Head.Id)
//testOntology.GetChildOntologyAnnotations(testTerms.Head.Id, Depth = 1)
//testOntology.GetChildOntologyAnnotations(testTerms.Head.Id, Depth = 2)



//let performanceTerms = List.init 7000000 (fun i -> OboTerm.Create($"lol:{i}"))
//let performanceOboOntology = OboOntology.create performanceTerms []
//OboOntology.toFile @"C:\Repos\CSBiology\FsOboParser\performanceOntology.obo" performanceOboOntology

//let x = OboOntology.fromFile false @"C:\Repos\CSBiology\FsOboParser\performanceOntology.obo"


//let fileLines = File.ReadAllLines testPath

//OboTerm.fromLines true ((fileLines |> Seq.ofArray).GetEnumerator()) 0

//OboOntology.toFile "myOboOntology.obo" testOboOntology

//Path.Combine("myOboOntology.obo") |> FileInfo

//let myOboTerm = OboTerm.Create("TO:00000000", Name = "testTerm", CreatedBy = "myself")

//let myOboTerm = 
//    OboTerm.create 
//        "TO:00000000" 
//        (Some "testTerm") 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        None 
//        (Some "myself") 
//        None

//OboTypeDef.Create

//let myOntology = OboOntology.create [myOboTerm] []

//OboOntology.toFile "myOboOntology.obo" myOntology

//let termOfInterest = testOntology.Terms[5]

//let isAs = testOntology.GetParentOntologyAnnotations(termOfInterest.Id)
// output is an ISADotNet.OntologyAnnotation list

//let isAsTerms = isAs |> List.map (fun oa -> testOntology.GetTerm(oa.TermAccessionString.ToString()))
// output is an OboTerm list