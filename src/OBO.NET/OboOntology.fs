namespace OBO.NET

open DBXref
//open OboTerm
//open OboTypeDef

open FSharpAux
open FSharpAux.Regex
open ARCtrl.ISA

open System
open System.IO


/// Ontology containing OBO Terms and OBO Type Defs (OBO 1.2).
type OboOntology =

    {
        Terms                                           : OboTerm list
        TypeDefs                                        : OboTypeDef list
        FormatVersion                                   : string
        DataVersion                                     : string option
        Ontology                                        : string option
        Date                                            : DateTime option
        SavedBy                                         : string option
        AutoGeneratedBy                                 : string option
        Subsetdefs                                      : string list
        Imports                                         : string list               // needs its own type (Record?)
        Synonymtypedefs                                 : string list               // rethink type, maybe create a mother type (Union? Maybe Record'd be better)
        Idspaces                                        : string list               // rethink as own Record type
        DefaultRelationshipIdPrefix                     : string option
        IdMappings                                      : string list               // rethink: maybe a new record? or TermRelation<string>?
        Remarks                                         : string list
        TreatXrefsAsEquivalents                         : string list
        TreatXrefsAsGenusDifferentias                   : string list               // rethink: maybe a new record? or plain string option?
        TreatXrefsAsRelationships                       : string list               // maybe better as its own (Record/Union?) type
        TreatXrefsAsIsAs                                : string list
        RelaxUniqueIdentifierAssumptionForNamespaces    : string list
        RelaxUniqueLabelAssumptionForNamespaces         : string list
    }

    /// Creates an OboOntology based on the given parameters.
    static member create terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idspaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces =
        {
            Terms                                           = terms
            TypeDefs                                        = typedefs
            FormatVersion                                   = formatVersion
            DataVersion                                     = dataVersion
            Ontology                                        = ontology
            Date                                            = date
            SavedBy                                         = savedBy
            AutoGeneratedBy                                 = autoGeneratedBy
            Subsetdefs                                      = subsetdefs
            Imports                                         = imports
            Synonymtypedefs                                 = synonymtypedefs
            Idspaces                                        = idspaces
            DefaultRelationshipIdPrefix                     = defaultRelationshipIdPrefix
            IdMappings                                      = idMappings
            Remarks                                         = remarks
            TreatXrefsAsEquivalents                         = treatXrefsAsEquivalents
            TreatXrefsAsGenusDifferentias                   = treatXrefsAsGenusDifferentias
            TreatXrefsAsRelationships                       = treatXrefsAsRelationships
            TreatXrefsAsIsAs                                = treatXrefsAsIsAs
            RelaxUniqueIdentifierAssumptionForNamespaces    = relaxUniqueIdentifierAssumptionForNamespaces
            RelaxUniqueLabelAssumptionForNamespaces         = relaxUniqueLabelAssumptionForNamespaces
        }

    /// Creates an OboOntology based on the given arguments.
    static member Create(terms, typedefs, formatVersion, ?DataVersion, ?Ontology, ?Date, ?SavedBy, ?AutoGeneratedBy, ?Subsetdefs, ?Imports, ?Synonymtypedefs, ?Idspaces, ?DefaultRelationshipIdPrefix, ?IdMappings, ?Remarks, ?TreatXrefsAsEquivalents, ?TreatXrefsAsGenusDifferentias, ?TreatXrefsAsRelationships, ?TreatXrefsAsIsAs, ?RelaxUniqueIdentifierAssumptionForNamespaces, ?RelaxUniqueLabelAssumptionForNamespaces) = {
        Terms                                           = terms
        TypeDefs                                        = typedefs
        FormatVersion                                   = formatVersion
        DataVersion                                     = DataVersion
        Ontology                                        = Ontology
        Date                                            = Date
        SavedBy                                         = SavedBy
        AutoGeneratedBy                                 = AutoGeneratedBy
        Subsetdefs                                      = defaultArg Subsetdefs []
        Imports                                         = defaultArg Imports []
        Synonymtypedefs                                 = defaultArg Synonymtypedefs []
        Idspaces                                        = defaultArg Idspaces []
        DefaultRelationshipIdPrefix                     = DefaultRelationshipIdPrefix
        IdMappings                                      = defaultArg IdMappings []
        Remarks                                         = defaultArg Remarks []
        TreatXrefsAsEquivalents                         = defaultArg TreatXrefsAsEquivalents []
        TreatXrefsAsGenusDifferentias                   = defaultArg TreatXrefsAsGenusDifferentias []
        TreatXrefsAsRelationships                       = defaultArg TreatXrefsAsRelationships []
        TreatXrefsAsIsAs                                = defaultArg TreatXrefsAsIsAs []
        RelaxUniqueIdentifierAssumptionForNamespaces    = defaultArg RelaxUniqueIdentifierAssumptionForNamespaces []
        RelaxUniqueLabelAssumptionForNamespaces         = defaultArg RelaxUniqueLabelAssumptionForNamespaces []
    }

    /// Reads an OBO Ontology containing document header tags, and term and type def stanzas from lines.
    static member fromLines verbose (input : seq<string>) =

        let rxFormatVersion                                 = createRegex RegexOptions.None @"format-version\s*:\s*(?<formatVersion>.+)"
        let rxDataVersion                                   = createRegex RegexOptions.None @"(?:data-version|version)\s*:\s*(?<dataVersion>.+)"
        let rxOntology                                      = createRegex RegexOptions.None @"ontology\s*:\s*(?<ontology>.+)"
        let rxDate                                          = createRegex RegexOptions.None @"date\s*:\s*(?<date>\d{2}:\d{2}:\d{4} \d{2}:\d{2})"
        let rxSavedBy                                       = createRegex RegexOptions.None @"saved-by\s*:\s*(?<savedBy>.+)"
        let rxAutoGeneratedBy                               = createRegex RegexOptions.None @"auto-generated-by\s*:\s*(?<autoGeneratedBy>.+)"
        let rxSubsetdef                                     = createRegex RegexOptions.None @"subsetdef\s*:\s*(?<subsetdef>.+)"
        let rxImport                                        = createRegex RegexOptions.None @"import\s*:\s*(?<import>.+)"
        let rxSynonymtypedef                                = createRegex RegexOptions.None @"synonymtypedef\s*:\s*(?<synonymtypedef>.+)"
        let rxIdspace                                       = createRegex RegexOptions.None @"idspace\s*:\s*(?<idspace>.+)"
        let rxDefaultRelationshipIdPrefix                   = createRegex RegexOptions.None @"default-relationship-id-prefix\s*:\s*(?<defaultRelationshipIdPrefix>.+)"
        let rxIdMapping                                     = createRegex RegexOptions.None @"id-mapping\s*:\s*(?<idMapping>.+)"
        let rxRemark                                        = createRegex RegexOptions.None @"remark\s*:\s*(?<remark>.+)"
        let rxTreatXrefsAsEquivalent                        = createRegex RegexOptions.None @"treat-xrefs-as-equivalent\s*:\s*(?<treatXrefsAsEquivalent>.+)"
        let rxTreatXrefsAsGenusDifferentia                  = createRegex RegexOptions.None @"treat-xrefs-as-genus-differentia\s*:\s*(?<treatXrefsAsGenusDifferentia>.+)"
        let rxTreatXrefsAsRelationship                      = createRegex RegexOptions.None @"treat-xrefs-as-relationship\s*:\s*(?<treatXrefsAsRelationship>.+)"
        let rxTreatXrefsAsIsA                               = createRegex RegexOptions.None @"treat-xrefs-as-is_a\s*:\s*(?<treatXrefsAsIsA>.+)"
        let rxRelaxUniqueIdentifierAssumptionForNamespace   = createRegex RegexOptions.None @"relax-unique-identifier-assumption-for-namespace\s*:\s*(?<relaxUniqueIdentifierAssumptionForNamespace>.+)"
        let rxRelaxUniqueLabelAssumptionForNamespace        = createRegex RegexOptions.None @"relax-unique-label-assumption-for-namespace\s*:\s*(?<relaxUniqueLabelAssumptionForNamespace>.+)"

        let en = input.GetEnumerator()

        let rec loop (en : Collections.Generic.IEnumerator<string>) terms typedefs formatVersion (dataVersion : string option) ontology (date : DateTime option) (savedBy : string option) (autoGeneratedBy : string option) subsetdefs imports synonymtypedefs idSpaces (defaultRelationshipIdPrefix : string option) idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces lineNumber =

            match en.MoveNext() with
            | true ->             
                match trimComment en.Current with
                | "[Term]"    -> 
                    let lineNumber,parsedTerm = OboTerm.fromLines verbose en lineNumber "" "" false [] "" "" [] [] [] [] [] [] [] [] false [] [] [] false "" ""
                    loop en (parsedTerm :: terms) typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsIsAs treatXrefsAsRelationships treatXrefsAsGenusDifferentias relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces lineNumber
                | "[Typedef]" -> 
                    let lineNumber,parsedTypeDef = OboTypeDef.fromLines verbose en lineNumber "" "" "" "" [] [] false false false false false false false
                    loop en terms (parsedTypeDef :: typedefs) formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces lineNumber
                | x when (rxFormatVersion.Match x).Success -> 
                    if formatVersion <> "" then printfn "WARNING: Duplicate format-version in document header tags!"
                    loop en terms typedefs (rxFormatVersion.Match x).Groups["formatVersion"].Value dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxDataVersion.Match x).Success ->
                    if dataVersion.IsSome then printfn "WARNING: Duplicate data-version in document header tags!"
                    loop en terms typedefs formatVersion (Some (rxDataVersion.Match x).Groups["dataVersion"].Value) ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxOntology.Match x).Success ->
                    loop en terms typedefs formatVersion dataVersion ((rxOntology.Match x).Groups["ontology"].Value |> Some) date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxDate.Match x).Success -> 
                    if date.IsSome then printfn "WARNING: Duplicate date in document header tags!"
                    let parsedDate = 
                        try DateTime.ParseExact((rxDate.Match x).Groups["date"].Value, "dd:MM:yyyy HH:mm", Globalization.CultureInfo.InvariantCulture) |> Some with
                            _ -> 
                                printfn "ERROR: Inproper date given!"
                                None
                    loop en terms typedefs formatVersion dataVersion ontology parsedDate savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxSavedBy.Match x).Success -> 
                    if savedBy.IsSome then printfn "WARNING: Duplicate saved-by in document header tags!"
                    loop en terms typedefs formatVersion dataVersion ontology date ((rxSavedBy.Match x).Groups["savedBy"].Value |> Some) autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxAutoGeneratedBy.Match x).Success -> 
                    if autoGeneratedBy.IsSome then printfn "WARNING: Duplicate auto-generated-by in document header tags!"
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy ((rxAutoGeneratedBy.Match x).Groups["autoGeneratedBy"].Value |> Some) subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxSubsetdef.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy ((rxSubsetdef.Match x).Groups["subsetdef"].Value :: subsetdefs) imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxImport.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs ((rxImport.Match x).Groups["import"].Value :: imports) synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxSynonymtypedef.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports ((rxSynonymtypedef.Match x).Groups["synonymtypedef"].Value :: synonymtypedefs) idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxIdspace.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs ((rxIdspace.Match x).Groups["idspace"].Value :: idSpaces) defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxDefaultRelationshipIdPrefix.Match x).Success -> 
                    if defaultRelationshipIdPrefix.IsSome then printfn "WARNING: Duplicate default-relationship-id-prefix in document header tags!"
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces ((rxDefaultRelationshipIdPrefix.Match x).Groups["defaultRelationshipIdPrefix"].Value |> Some) idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxIdMapping.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix ((rxIdMapping.Match x).Groups["idMapping"].Value :: idMappings) remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxRemark.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings ((rxRemark.Match x).Groups["remark"].Value :: remarks) treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxTreatXrefsAsEquivalent.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks ((rxTreatXrefsAsEquivalent.Match x).Groups["treatXrefsAsEquivalent"].Value :: treatXrefsAsEquivalents) treatXrefsAsIsAs treatXrefsAsRelationships treatXrefsAsGenusDifferentias relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxTreatXrefsAsGenusDifferentia.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents ((rxTreatXrefsAsGenusDifferentia.Match x).Groups["treatXrefsAsGenusDifferentia"].Value :: treatXrefsAsGenusDifferentias) treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxTreatXrefsAsRelationship.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias ((rxTreatXrefsAsRelationship.Match x).Groups["treatXrefsAsRelationship"].Value :: treatXrefsAsRelationships) treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxTreatXrefsAsIsA.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships ((rxTreatXrefsAsIsA.Match x).Groups["treatXrefsAsIsA"].Value :: treatXrefsAsIsAs) relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxRelaxUniqueIdentifierAssumptionForNamespace.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs ((rxRelaxUniqueIdentifierAssumptionForNamespace.Match x).Groups["relaxUniqueIdentifierAssumptionForNamespace"].Value :: relaxUniqueIdentifierAssumptionForNamespaces) relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
                | x when (rxRelaxUniqueLabelAssumptionForNamespace.Match x).Success -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces ((rxRelaxUniqueLabelAssumptionForNamespace.Match x).Groups["relaxUniqueLabelAssumptionForNamespace"].Value :: relaxUniqueLabelAssumptionForNamespaces) (lineNumber + 1)
                | _ -> 
                    loop en terms typedefs formatVersion dataVersion ontology date savedBy autoGeneratedBy subsetdefs imports synonymtypedefs idSpaces defaultRelationshipIdPrefix idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces (lineNumber + 1)
            | false -> 
                OboOntology.create (List.rev terms) (List.rev typedefs) formatVersion dataVersion ontology date savedBy autoGeneratedBy (List.rev subsetdefs) (List.rev imports) (List.rev synonymtypedefs) (List.rev idSpaces) defaultRelationshipIdPrefix (List.rev idMappings) (List.rev remarks) (List.rev treatXrefsAsEquivalents) (List.rev treatXrefsAsGenusDifferentias) (List.rev treatXrefsAsRelationships) (List.rev treatXrefsAsIsAs) (List.rev relaxUniqueIdentifierAssumptionForNamespaces) (List.rev relaxUniqueLabelAssumptionForNamespaces)

        loop en [] [] String.Empty None None None None None [] [] [] [] None [] [] [] [] [] [] [] [] 0  // was 1 before

    /// Reads an OBO Ontology containing term and type def stanzas from a file with the given path.
    static member fromFile verbose (path : string) =
        File.ReadAllLines path
        |> OboOntology.fromLines verbose

    /// Takes a list of OboEntries and the document header tags and returns the OboOntology based on them.
    static member fromOboEntries formatVersion (dataVersion : string option) ontology (date : DateTime option) (savedBy : string option) (autoGeneratedBy : string option) subsetdefs imports synonymtypedefs idSpaces (defaultRelationshipIdPrefix : string option) idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces entries =

        let rec loop terms typedefs entries =
            match entries with
            | h :: t ->
                match h with
                | Term term         -> loop (term :: terms) typedefs t
                | TypeDef typedef   -> loop terms (typedef :: typedefs) t
            | [] -> terms, typedefs

        let terms, typedefs = loop [] [] entries

        OboOntology.create terms typedefs formatVersion dataVersion ontology (date : DateTime option) (savedBy : string option) (autoGeneratedBy : string option) subsetdefs imports synonymtypedefs idSpaces (defaultRelationshipIdPrefix : string option) idMappings remarks treatXrefsAsEquivalents treatXrefsAsGenusDifferentias treatXrefsAsRelationships treatXrefsAsIsAs relaxUniqueIdentifierAssumptionForNamespaces relaxUniqueLabelAssumptionForNamespaces

    /// Takes a list of OboEntries and the document header tags and returns the OboOntology based on them.
    static member FromOboEntries(entries, formatVersion, ?DataVersion, ?Ontology, ?Date, ?SavedBy, ?AutoGeneratedBy, ?Subsetdefs, ?Imports, ?Synonymtypedefs, ?Idspaces, ?DefaultRelationshipIdPrefix, ?IdMappings, ?Remarks, ?TreatXrefsAsEquivalents, ?TreatXrefsAsGenusDifferentias, ?TreatXrefsAsRelationships, ?TreatXrefsAsIsAs, ?RelaxUniqueIdentifierAssumptionForNamespaces, ?RelaxUniqueLabelAssumptionForNamespaces) =
        //let subsetdefs = match Subsetdefs with None -> [] | _ -> Subsetdefs.Value
        OboOntology.fromOboEntries formatVersion DataVersion Ontology Date SavedBy AutoGeneratedBy (defaultArg Subsetdefs []) (defaultArg Imports []) (defaultArg Synonymtypedefs []) (defaultArg Idspaces []) DefaultRelationshipIdPrefix (defaultArg IdMappings []) (defaultArg Remarks []) (defaultArg TreatXrefsAsEquivalents []) (defaultArg TreatXrefsAsGenusDifferentias []) (defaultArg TreatXrefsAsRelationships []) (defaultArg TreatXrefsAsIsAs []) (defaultArg RelaxUniqueIdentifierAssumptionForNamespaces []) (defaultArg RelaxUniqueLabelAssumptionForNamespaces []) entries

    /// Writes an OBO Ontology to term and type def stanzas in line form.
    static member toLines (oboOntology : OboOntology) =
        seq {
            for term in oboOntology.Terms do
                yield "[Term]"
                yield! OboTerm.toLines term
                yield ""

            for typedef in oboOntology.TypeDefs do
                yield "[Typedef]"
                yield! OboTypeDef.toLines typedef
                yield ""
        }

    /// Writes an OBO Ontology to term and type def stanzas to a file in the given path.
    static member toFile (path : string) (oboOntology : OboOntology) =
        File.WriteAllLines(path, OboOntology.toLines oboOntology)

    /// Writes an OBO Ontology to term and type def stanzas in line form.
    member this.ToLines() = 
        OboOntology.toLines this

    /// Writes an OBO Ontology to term and type def stanzas to a file in the given path.
    member this.ToFile(path : string) =
        OboOntology.toFile path this

    /// Finds OBO term by "TermSourceRef:TermAccessionNumber" style ID.
    member this.TryGetTerm(id : string) = 
        this.Terms
        |> List.tryFind (fun t ->
            t.Id = id
        )

    /// Finds OBO term by "TermSourceRef:TermAccessionNumber" style ID.
    member this.GetTerm(id : string) = 
        this.Terms
        |> List.find (fun t ->
            t.Id = id
        )

    /// Finds OBO term by "TermSourceRef:TermAccessionNumber" style ID and returns it as ISA OntologyAnnotation type.
    member this.TryGetOntologyAnnotation(id : string) = 
        this.Terms
        |> List.tryPick (fun t ->
            if t.Id = id then Some (OboTerm.toOntologyAnnotation t) else None
        )

    /// Finds OBO term by "TermSourceRef:TermAccessionNumber" style ID and returns it as ISA OntologyAnnotation type.
    member this.GetOntologyAnnotation(id : string) = 
        this.Terms
        |> List.pick (fun t ->
            if t.Id = id then Some (OboTerm.toOntologyAnnotation t) else None
        )

    /// Finds OBO term by its free text name if it exists. Else returns None.
    member this.TryGetTermByName(name : string) = 
        this.Terms
        |> List.tryFind (fun t ->
            t.Name = name
        )

    /// Finds OBO term by its free text name.
    member this.GetTermByName(name : string) = 
        this.Terms
        |> List.find (fun t ->
            t.Name = name
        )

    /// Finds OBO term by its free text name and returns it as ISA OntologyAnnotation type if it exists. Else returns None.
    member this.TryGetOntologyAnnotationByName(name : string) = 
        this.Terms
        |> List.tryPick (fun t ->
            if t.Name = name then Some (OboTerm.toOntologyAnnotation t) else None
        )

    /// Finds OBO term by it's free text name and return it as ISA OntologyAnnotation type.
    member this.GetOntologyAnnotationByName(name : string) = 
        this.Terms
        |> List.pick (fun t ->
            if t.Name = name then Some (OboTerm.toOntologyAnnotation t) else None
        )

    /// For a given ontology term, finsd all equivalent terms that are connected via XRefs.
    ///
    /// Depth can be used to restrict the number of iterations by which neighbours of neighbours are checked.
    member this.GetEquivalentOntologyAnnotations(term : OntologyAnnotation, ?Depth : int) =
            
        let rec loop depth (equivalents : OntologyAnnotation list) (lastLoop : OntologyAnnotation list) =
            if equivalents.Length = lastLoop.Length then equivalents
            elif Depth.IsSome && Depth.Value < depth then equivalents
            else
                let newEquivalents = 
                    equivalents
                    |> List.collect (fun t ->
                        let forward = 
                            match this.TryGetTerm t.TermAccessionShort with
                            | Some term ->
                                term.Xrefs
                                |> List.map (fun xref ->
                                    let id = OntologyAnnotation.fromTermAnnotation(xref.Name).TermAccessionShort
                                    match this.TryGetOntologyAnnotation id with
                                    | Some oa ->
                                        oa
                                    | None -> 
                                        OntologyAnnotation.fromString(tan = xref.Name)
                                )
                            | None ->
                                []
                        let backward = 
                            this.Terms
                            |> List.filter (fun term ->
                                term.Xrefs
                                |> List.exists (fun xref ->
                                    t.Equals(xref.Name)
                                )
                            )
                            |> List.map (fun ot -> OboTerm.toOntologyAnnotation ot)
                        forward @ backward
                    )
                loop (depth + 1) (equivalents @ newEquivalents |> List.distinct) equivalents
        loop 1 [term] []
        |> List.filter ((<>) term)

    /// For a given ontology term, finds all equivalent terms that are connected via XRefs.
    ///
    /// Depth can be used to restrict the number of iterations by which neighbours of neighbours are checked.
    member this.GetEquivalentOntologyAnnotations(termId : string, ?Depth) =
        match Depth with 
        | Some d ->
            OntologyAnnotation.fromTermAnnotation termId         
            |> fun oa -> this.GetEquivalentOntologyAnnotations(oa, d)
        | None -> 
            OntologyAnnotation.fromTermAnnotation termId    
            |> this.GetEquivalentOntologyAnnotations

    /// For a given ontology term, finds all terms to which this term points in a "isA" relationship.
    ///
    /// Depth can be used to restrict the number of iterations by which neighbours of neighbours are checked.
    member this.GetParentOntologyAnnotations(term : OntologyAnnotation, ?Depth) =
        let rec loop depth (equivalents : OntologyAnnotation list) (lastLoop : OntologyAnnotation list) =
            if equivalents.Length = lastLoop.Length then equivalents
            elif Depth.IsSome && Depth.Value < depth then equivalents
            else
                let newEquivalents = 
                    equivalents
                    |> List.collect (fun t ->
                        match this.TryGetTerm t.TermAccessionShort with
                        | Some term ->
                            term.IsA
                            |> List.map (fun isA ->
                                match this.TryGetOntologyAnnotation isA with
                                | Some oa ->
                                    oa
                                | None -> 
                                    OntologyAnnotation.fromString(tan = isA)
                            )
                        | None ->
                            []
                    )
                loop (depth + 1) (equivalents @ newEquivalents |> List.distinct) equivalents
        loop 1 [term] []
        |> List.filter ((<>) term)

    /// For a given ontology term, find all terms to which this term points in a "isA" relationship
    ///
    /// Depth can be used to restrict the number of iterations by which neighbours of neighbours are checked.
    member this.GetParentOntologyAnnotations(termId : string, ?Depth) =
        match Depth with 
        | Some d ->
            OntologyAnnotation.fromTermAnnotation termId
            |> fun oa -> this.GetParentOntologyAnnotations(oa, d)
        | None -> 
            OntologyAnnotation.fromTermAnnotation termId
            |> this.GetParentOntologyAnnotations

    /// For a given ontology term, finds all terms which point to this term "isA" relationship.
    ///
    /// Depth can be used to restrict the number of iterations by which neighbours of neighbours are checked.
    member this.GetChildOntologyAnnotations(term : OntologyAnnotation, ?Depth) =
        let rec loop depth (equivalents : OntologyAnnotation list) (lastLoop : OntologyAnnotation list) =
            if equivalents.Length = lastLoop.Length then equivalents
            elif Depth.IsSome && Depth.Value < depth then equivalents
            else
                let newEquivalents = 
                    equivalents
                    |> List.collect (fun t ->
                        this.Terms
                        |> List.choose (fun pt -> 
                            let isChild = 
                                pt.IsA
                                |> List.exists (fun isA -> t.TermAccessionShort = isA)
                            if isChild then
                                Some (OboTerm.toOntologyAnnotation(pt))
                            else
                                None

                        )
                    )
                loop (depth + 1) (equivalents @ newEquivalents |> List.distinct) equivalents
        loop 1 [term] []
        |> List.filter ((<>) term)

    /// For a given ontology term, finds all terms which point to this term "isA" relationship.
    ///
    /// Depth can be used to restrict the number of iterations by which neighbours of neighbours are checked.
    member this.GetChildOntologyAnnotations(termId : string, ?Depth) =
        match Depth with 
        | Some d ->
            OntologyAnnotation.fromTermAnnotation termId
            |> fun oa -> this.GetChildOntologyAnnotations(oa, d)
        | None -> 
            OntologyAnnotation.fromTermAnnotation termId
            |> this.GetChildOntologyAnnotations

    /// Takes an OboTerm and returns all related terms in this ontology as a triple of input term, relationship, and related term.
    member this.GetRelatedTerms(term : OboTerm) =
        term.Relationships
        |> List.map (
            OboTerm.deconstructRelationship
            >> fun (r,tId) -> 
                term, 
                r, 
                this.Terms
                |> List.tryFind (
                    fun t -> t.Id = tId
                )
        )

    /// Takes an OboTerm and an OboOntology and returns all related terms in this ontology as a triple of input term, relationship, and related term.
    static member getRelatedTerms term (ontology : OboOntology) =
        ontology.GetRelatedTerms term

    /// Takes an OboTerm and returns a list of the input OboTerm and all OboTerms that this OboTerm is related with via is_a.
    member this.GetIsAs(term : OboTerm) =
        term.IsA
        |> List.map (
            fun id ->
                term,
                this.Terms
                |> List.tryFind (fun t -> t.Id = id)
        )

    /// Takes an OboTerm and an OboOntology and returns a list of the input OboTerm and all OboTerms that this OboTerm is related with via is_a.
    static member getIsAs term (ontology: OboOntology) =
        ontology.GetIsAs term

    /// Returns all relations in this OboOntology as a list of TermRelations.
    member this.GetRelations() =
        [for t in this.Terms do
            match List.isEmpty t.Relationships && List.isEmpty t.IsA with
            | true -> Empty t
            | false ->
                yield! 
                    this.GetRelatedTerms t
                    |> List.map (
                        fun (st,rs,tto) -> 
                            match tto with
                            | Some tt -> Target (rs, st, tt)
                            | None -> TargetMissing (rs, st)
                    )
                yield!
                    this.GetIsAs t
                    |> List.map (
                        fun (st,tto) ->
                            match tto with
                            | Some tt -> Target ("is_a", st, tt)
                            | None -> TargetMissing ("is_a", st)
                    )
        ]

    /// Returns all relations in the given OboOntology as a list of TermRelations.
    static member getRelations (ontology : OboOntology) =
        ontology.GetRelations()

    /// Takes a given OboTerm and returns a sequence of scope * OboTerm if the synonym exists in the OboOntology or scope * None if it does not.
    member this.TryGetSynonyms(term : OboTerm) =
        term.Synonyms
        |> Seq.map (
            fun s -> 
                s.Scope,
                term,
                this.Terms 
                |> Seq.tryFind (
                    fun t -> 
                        t.Name = String.replace "\"" "" s.Text
                )
        )

    /// Takes a given OboTerm and returns a sequence of scope * OboTerm if the synonym exists in the given OboOntology or scope * None if it does not.
    static member tryGetSynonymTerms term (onto : OboOntology) =
        onto.TryGetSynonyms term

    /// Takes a given OboTerm and returns a sequence of scope * OboTerm if the synonym exists in the OboOntology.
    member this.GetSynonyms(term : OboTerm) =
        term.Synonyms
        |> Seq.choose (
            fun s -> 
                let sto =
                    this.Terms 
                    |> Seq.tryFind (
                        fun t -> 
                            t.Name = String.replace "\"" "" s.Text
                    )
                match sto with
                | Some st -> Some (s.Scope, term, st)
                | None -> None
        )

    /// Takes a given OboTerm and returns a sequence of scope * OboTerm if the synonym exists in the given OboOntology.
    static member getSynonyms term (onto : OboOntology) =
        onto.GetSynonyms term


type OboTermDef = 
    {
        Id           : string
        Name         : string
        IsTransitive : string
        IsCyclic     : string
    }

    static member make id name  isTransitive isCyclic =
        {Id = id; Name = name; IsTransitive = isTransitive; IsCyclic = isCyclic}

    //parseTermDef
    static member fromLines (en:Collections.Generic.IEnumerator<string>) id name isTransitive isCyclic =     
        if en.MoveNext() then                
            let split = (en.Current |> trimComment).Split([|": "|], System.StringSplitOptions.None)
            match split.[0] with
            | "id"            -> OboTermDef.fromLines en (split.[1..] |> String.concat ": ") name isTransitive isCyclic
            | "name"          -> OboTermDef.fromLines en id (split.[1..] |> String.concat ": ") isTransitive isCyclic 
            | "is_transitive" -> OboTermDef.fromLines en id name (split.[1..] |> String.concat ": ") isCyclic
            | "is_cyclic"     -> OboTermDef.fromLines en id name isTransitive (split.[1..] |> String.concat ": ")
            | ""              -> OboTermDef.make id name isTransitive isCyclic
            | _               -> OboTermDef.fromLines en id name isTransitive isCyclic
        else
            // Maybe check if id is empty
            OboTermDef.make id name isTransitive isCyclic
            //failwithf "Unexcpected end of file."


/// Functions for parsing and querying an OBO ontology.
module OboOntology =

    /// Parses OBO Terms [Term] from seq<string>.
    [<Obsolete("Use static method fromLines instead")>]
    let parseOboTerms verbose (input:seq<string>)  =

        let en = input.GetEnumerator()
        let rec loop (en:System.Collections.Generic.IEnumerator<string>) lineNumber =
            seq {
                match en.MoveNext() with
                | true ->
                    match (en.Current |> trimComment) with
                    | "[Term]" -> 
                        let lineNumber,parsedTerm = (OboTerm.fromLines verbose en lineNumber "" "" false [] "" "" [] [] [] [] [] [] [] [] false [] [] [] false "" "")
                        yield parsedTerm
                        yield! loop en lineNumber
                    | _ -> yield! loop en (lineNumber + 1)
                | false -> ()
            }
        loop en 1